/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Please refer to the README for information about making permanent changes.  #
################################################################################
*/

#ifndef QML_ZPOLLER_H
#define QML_ZPOLLER_H

#include <QtQml>

#include <czmq.h>
#include "qml_czmq_plugin.h"


class QmlZpoller : public QObject
{
    Q_OBJECT
    Q_PROPERTY(bool isNULL READ isNULL)
    
public:
    zpoller_t *self;
    
    QmlZpoller() { self = NULL; }
    bool isNULL() { return self == NULL; }
    
    static QObject* qmlAttachedProperties(QObject* object); // defined in QmlZpoller.cpp
    
public slots:
    //  Add a reader to be polled. Returns 0 if OK, -1 on failure. The reader may
    //  be a libzmq void * socket, a zsock_t instance, or a zactor_t instance.   
    int add (void *reader);

    //  Remove a reader from the poller; returns 0 if OK, -1 on failure. The   
    //  reader may be a libzmq void * socket, a zsock_t instance, or a zactor_t
    //  instance.                                                              
    int remove (void *reader);

    //  Poll the registered readers for I/O, return first reader that has input.  
    //  The reader will be a libzmq void * socket, or a zsock_t or zactor_t       
    //  instance as specified in zpoller_new/zpoller_add. The timeout should be   
    //  zero or greater, or -1 to wait indefinitely. Socket priority is defined   
    //  by their order in the poll list. If you need a balanced poll, use the low 
    //  level zmq_poll method directly. If the poll call was interrupted (SIGINT),
    //  or the ZMQ context was destroyed, or the timeout expired, returns NULL.   
    //  You can test the actual exit condition by calling zpoller_expired () and  
    //  zpoller_terminated (). The timeout is in msec.                            
    void *wait (int timeout);

    //  Return true if the last zpoller_wait () call ended because the timeout
    //  expired, without any error.                                           
    bool expired ();

    //  Return true if the last zpoller_wait () call ended because the process
    //  was interrupted, or the parent context was destroyed.                 
    bool terminated ();

    //  Ignore zsys_interrupted flag in this poller. By default, a zpoller_wait will 
    //  return immediately if detects zsys_interrupted is set to something other than
    //  zero. Calling zpoller_ignore_interrupts will supress this behavior.          
    void ignoreInterrupts ();
};

class QmlZpollerAttached : public QObject
{
    Q_OBJECT
    QObject* m_attached;
    
public:
    QmlZpollerAttached (QObject* attached) {
        Q_UNUSED (attached);
    };
    
public slots:
    //  Self test of this class
    void test (bool verbose);

    //  Create new poller; the reader can be a libzmq socket (void *), a zsock_t
    //  instance, or a zactor_t instance.                                       
    QmlZpoller *construct (void *reader);

    //  Destroy a poller
    void destruct (QmlZpoller *qmlSelf);
};


QML_DECLARE_TYPEINFO(QmlZpoller, QML_HAS_ATTACHED_PROPERTIES)

#endif
/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Please refer to the README for information about making permanent changes.  #
################################################################################
*/
