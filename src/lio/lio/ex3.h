/*
Copyright 2016 Vanderbilt University

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/** \file
* Autogenerated public API
*/

#ifndef ACCRE_LIO_EX3_ABSTRACT_H_INCLUDED
#define ACCRE_LIO_EX3_ABSTRACT_H_INCLUDED

#include <apr_hash.h>
#include <apr_thread_cond.h>
#include <gop/tp.h>
#include <ibp/ibp.h>
#include <inttypes.h>
#include <lio/ds.h>
#include <lio/ex3_fwd.h>
#include <lio/visibility.h>
#include <lio/rs.h>
#include <lio/service_manager.h>
#include <tbx/iniparse.h>
#include <tbx/list.h>
#include <tbx/log.h>

// Typedefs are in ex3/fwd.h to break a potential dependency cycle

// Functions
LIO_API gop_op_generic_t *lio_exnode_clone_gop(gop_thread_pool_context_t *tpc, lio_exnode_t *src_ex, data_attr_t *da, lio_exnode_t **ex, void *arg, int mode, int timeout);
LIO_API lio_exnode_t *lio_exnode_create();
LIO_API lio_segment_t *lio_exnode_default_get(lio_exnode_t *ex);
LIO_API int lio_exnode_deserialize(lio_exnode_t *ex, lio_exnode_exchange_t *exp, lio_service_manager_t *ess);
LIO_API void lio_exnode_destroy(lio_exnode_t *ex);
LIO_API lio_exnode_exchange_t *lio_exnode_exchange_create(int type);
LIO_API void lio_exnode_exchange_destroy(lio_exnode_exchange_t *exp);
LIO_API lio_exnode_exchange_t *lio_exnode_exchange_load_file(char *fname);
LIO_API lio_exnode_exchange_t *lio_exnode_exchange_text_parse(char *text);
LIO_API int lio_exnode_serialize(lio_exnode_t *ex, lio_exnode_exchange_t *exp);
LIO_API gop_op_generic_t *lio_segment_copy_gop(gop_thread_pool_context_t *tpc, data_attr_t *da, lio_segment_rw_hints_t *rw_hints, lio_segment_t *src_seg, lio_segment_t *dest_seg, ex_off_t src_offset, ex_off_t dest_offset, ex_off_t len, ex_off_t bufsize, char *buffer, int do_truncate, int timoeut);
LIO_API int lio_view_insert(lio_exnode_t *ex, lio_segment_t *view);
LIO_API lio_service_manager_t *lio_exnode_service_set_create();
LIO_API void lio_exnode_service_set_destroy(lio_service_manager_t *ess);

// Preprocessor constants
typedef enum lio_ex3_format_t lio_ex3_format_t;
enum lio_ex3_format_t {
    EX_TEXT,
    EX_PROTOCOL_BUFFERS,
};

typedef enum lio_ex3_clone_t lio_ex3_clone_t;
enum lio_ex3_clone_t {
    CLONE_STRUCTURE,
    CLONE_STRUCT_AND_DATA,
};

typedef enum lio_ex3_inspect_command_t lio_ex3_inspect_command_t;
enum lio_ex3_inspect_command_t {
    INSPECT_NO_CHECK,
    INSPECT_QUICK_CHECK,
    INSPECT_SCAN_CHECK,
    INSPECT_FULL_CHECK,
    INSPECT_QUICK_REPAIR,
    INSPECT_SCAN_REPAIR,
    INSPECT_FULL_REPAIR,
    INSPECT_SOFT_ERRORS,
    INSPECT_HARD_ERRORS,
    INSPECT_MIGRATE,
    INSPECT_WRITE_ERRORS,
    /* NOTE: If you add another enumeration, you must change the
     *       following line as well.
     */
};
/* WRITE_ERRORS is 10 (0b1010 AKA 0xA), so we need to mask 4 bits: 0b1111 AKA
 * 0xF
 */
#define INSPECT_COMMAND_BITS (0xF)

/* FIXME: this seems awfully scattered around. Try and solve this too */
#define INSPECT_FORCE_REPAIR          (1 << 7)   //** Make the repair even if it leads to data loss

#define SEG_SM_CREATE "segment_create"

#define INSPECT_RESULT_FULL_CHECK   (1 << 9)    //** Full byte-level check performed
#define INSPECT_RESULT_SOFT_ERROR   (1 << 10)  //** Soft errors found
#define INSPECT_RESULT_HARD_ERROR   (1 << 11)   //** Hard errors found

#define INSPECT_SOFT_ERROR_FAIL       (1 << 8)   //** Treat soft errors as hard
#define INSPECT_FORCE_RECONSTRUCTION  (1 << 9)   //** Don't use depot-depot copies for data movement.  Instead use reconstruction
#define INSPECT_FAIL_ON_ERROR        (1 << 10)   //** Kick out if an unrecoverable error is hit
#define INSPECT_FIX_READ_ERROR       (1 << 11)   //** Treat read errors as bad blocks for repair
#define INSPECT_FIX_WRITE_ERROR      (1 << 12)   //** Treat write errors as bad blocks for repair

#define XIDT "%" PRIu64    //uint64_t
#define XOT  "%" PRId64    //int64_t
#define PXOT     PRId64    // Drop the % for formatting ..int64_t
#define XOTC PRId64

// Preprocessor macros
#define ex_iovec_single(iov, oset, nbytes) (iov)->offset = oset; (iov)->len = nbytes

// Exported types. To be obscured
struct lio_ex_header_t {
    char *name;
    ex_id_t id;
    char *type;
    tbx_list_t *attributes;  //should be a key/value pair struct?
};

struct lio_rid_inspect_tweak_t {
    lio_rid_change_entry_t *rid;
    apr_hash_t *pick_pool;
};

struct lio_inspect_args_t {
    rs_query_t *query;   //** Generic extra query
    gop_opque_t *qs;         //** Cleanup Que on success
    gop_opque_t *qf;         //** Cleanup Que for failure
    apr_hash_t *rid_changes;  //** List of RID space changes
    apr_thread_mutex_t *rid_lock;     //** Lock for manipulating the rid_changes table
    tbx_stack_t *bad_ranges;      //** List of bad byte ranges
    int n_dev_rows;
    int dev_row_replaced[128];
};

struct lio_exnode_text_t {
    char *text;
    tbx_inip_file_t *fd;
};

struct lio_exnode_exchange_t {
    lio_ex3_format_t type;
    lio_exnode_text_t text;
};

#ifdef __cplusplus
}
#endif

#endif /* ^ ACCRE_LIO_EX3_ABSTRACT_H_INCLUDED ^ */ 
